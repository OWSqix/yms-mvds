# docker-compose-node.yaml (템플릿)
services:
  caddy:
    image: 'caddy:2.8'
    restart: 'always'
    ports:
      - '80:80' # 각 노트북의 주 진입점
    volumes:
      - './caddyfiles/Caddyfile.cp-with-integrated-dp:/etc/caddy/Caddyfile'
    environment:
      CONNECTOR_UPSTREAM_HOST: 'connector'
      FRONTEND_UPSTREAM_HOST: 'connector-ui'

  connector-ui:
    image: 'NODE_UI_IMAGE_AND_TAG' # 예: ymslogoui:1.0 또는 kotilogoui:1.0
    restart: 'always'
    environment:
      EDC_UI_MANAGEMENT_API_URL: '/api/management'
      EDC_UI_MANAGEMENT_API_KEY: 'API_KEY_FOR_THIS_NODE' # 이 노드 전용 API 키
      EDC_UI_CONFIG_URL: 'false'
      NGINX_ACCESS_LOG: 'off'
      EDC_UI_ACTIVE_PROFILE: 'NODE_UI_PROFILE' # 예: ymatics-edc-connector 또는 koti-edc-connector

  connector:
    image: 'ghcr.io/sovity/edc-ce:latest'
    restart: 'always'
    depends_on:
      connector-db:
        condition: 'service_healthy'
    environment:
      sovity.deployment.kind: 'control-plane-with-integrated-data-plane'
      sovity.edc.fqdn.public: 'IP_OF_THIS_NOTEBOOK' # 이 노트북의 실제 IP
      sovity.edc.fqdn.internal: 'connector'
      edc.control.endpoint: 'http://connector:11004/api/control'
      sovity.jdbc.url: 'jdbc:postgresql://connector-db:5432/db-name'
      sovity.jdbc.user: 'db-user'
      sovity.jdbc.password: 'db-pass'
      edc.ui.active.profile: 'NODE_UI_PROFILE' # connector-ui와 동일한 프로필
      edc.ui.logout.url: 'https://example.com/logout'
      # 다른 두 노트북의 DSP 엔드포인트 명시
      edc.ui.catalog.urls: 'http://IP_OF_OTHER_NOTEBOOK_1/api/dsp,http://IP_OF_OTHER_NOTEBOOK_2/api/dsp'
      sovity.management.api.iam.kind: 'management-iam-api-key'
      edc.api.auth.key: 'API_KEY_FOR_THIS_NODE' # connector-ui와 동일한 API 키
      sovity.edc.title: 'Connector [A/B/C] Title' # 각 노드에 맞게 수정
      sovity.edc.description: 'Connector [A/B/C] Description'
      sovity.edc.maintainer.name: 'Connector [A/B/C] Maintainer'
      sovity.edc.maintainer.url: 'http://IP_OF_THIS_NOTEBOOK/maintainer'
      sovity.edc.curator.name: 'Connector [A/B/C] Curator'
      sovity.edc.curator.url: 'http://IP_OF_THIS_NOTEBOOK/curator'
      sovity.dataspace.kind: 'sovity-mock-iam' # 필요시 IAM 종류 변경
      edc.participant.id: 'UNIQUE_PARTICIPANT_ID_FOR_THIS_NODE' # 예: connector-node-a
      sovity.http.protocol: 'http://'
      sovity.print.config: 'true'
      sovity.logging.level: 'DEBUG'
      sovity.logging.kind: 'console'
      sovity.micrometer.enabled: 'true'

  connector-db:
    image: 'docker.io/postgres:16-alpine'
    restart: 'always'
    environment:
      POSTGRES_USER: 'db-user'
      POSTGRES_PASSWORD: 'db-pass'
      POSTGRES_DB: 'db-name'
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U db-user --dbname=db-name']
      interval: '1s'
      timeout: '5s'
      retries: 10
    volumes:
      - 'connector-db-data_NODE_SUFFIX:/var/lib/postgresql/data' # 볼륨 이름에 노드별 접미사 추가 (예: _node_a)

  datasink-backend:
    build:
      context: ./backend # 각 노트북에 'backend' 디렉토리 필요
      dockerfile: Dockerfile
    image: 'datasink-backend-node-NODE_SUFFIX:latest' # 이미지 이름에 노드별 접미사
    restart: always
    ports:
      # 각 노트북에서 동일 포트 사용 가능 (예: 8000, 8001)
      - "8000:8002"  # Data Sink API
      - "8001:8003"  # Data Source API
    volumes:
      - ./data:/app/data # 각 노드별 데이터 디렉토리
      - ./backend/logs:/app/backend/logs
    environment:
      - LOG_LEVEL=debug
      - HOST=0.0.0.0

  datasink-frontend:
    build:
      context: ./frontend # 각 노트북에 'frontend' 디렉토리 필요
      dockerfile: Dockerfile
      args:
        # 이 노트북의 백엔드 API 주소 (호스트 IP와 매핑된 포트 사용)
        - DATA_SINK_API_URL=http://IP_OF_THIS_NOTEBOOK:8000
        - DATA_SOURCE_API_URL=http://IP_OF_THIS_NOTEBOOK:8001
    image: 'datasink-frontend-node-NODE_SUFFIX:latest' # 이미지 이름에 노드별 접미사
    ports:
      # 각 노트북에서 동일 포트 사용 가능 (예: 4200)
      - "4200:4200"
    depends_on:
      - datasink-backend

volumes:
  connector-db-data_NODE_SUFFIX: # 예: connector-db-data_node_a
    driver: 'local'